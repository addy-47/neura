<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Neura AI Interface - Glass Sphere Animation</title>
  <style>
    body { 
      margin: 0;
      overflow: hidden;
      background-color: #111;
      color: white;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    }
    #canvas-container {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 1;
    }
    #ui-container {
      position: fixed;
      bottom: 20px;
      left: 20px;
      z-index: 2;
      background-color: rgba(0, 0, 0, 0.7);
      padding: 20px;
      border-radius: 10px;
      max-width: 400px;
    }
    h1 {
      margin-top: 0;
      font-size: 24px;
    }
    p {
      margin: 10px 0;
      font-size: 14px;
      line-height: 1.5;
    }
    .control-buttons {
      display: flex;
      flex-direction: column;
      gap: 10px;
      margin-top: 20px;
    }
    button {
      background-color: #333;
      color: white;
      border: none;
      padding: 10px 15px;
      border-radius: 5px;
      cursor: pointer;
      transition: background-color 0.3s;
    }
    button:hover {
      background-color: #444;
    }
    button.active {
      background-color: #555;
      box-shadow: 0 0 10px rgba(255, 255, 255, 0.3);
    }
    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    .sample-sentences {
      margin-top: 15px;
      padding: 10px;
      background-color: rgba(255, 255, 255, 0.1);
      border-radius: 5px;
    }
    .sample-sentence {
      margin: 8px 0;
      padding: 8px;
      background-color: rgba(255, 255, 255, 0.05);
      border-radius: 3px;
      cursor: pointer;
      transition: background-color 0.2s;
    }
    .sample-sentence:hover {
      background-color: rgba(255, 255, 255, 0.1);
    }
    .sample-sentence.active {
      background-color: rgba(255, 255, 255, 0.15);
    }
    #current-text {
      margin-top: 15px;
      font-size: 16px;
      font-weight: bold;
      min-height: 24px;
    }
  </style>
</head>
<body>
  <div id="canvas-container"></div>
  
  <div id="ui-container">
    <h1>Neura AI Interface</h1>
    <p>Glass sphere visualization with word-reactive wave distortions</p>
    
    <div id="current-text"></div>
    
    <div class="control-buttons">
      <button id="stop-button">Stop Animation</button>
      
      <div class="sample-sentences">
        <strong>Sample Sentences:</strong>
        <div class="sample-sentence" data-text="Hello, how can I help you today?">Hello, how can I help you today?</div>
        <div class="sample-sentence" data-text="The quick brown fox jumps over the lazy dog.">The quick brown fox jumps over the lazy dog.</div>
        <div class="sample-sentence" data-text="Artificial intelligence is transforming the world.">Artificial intelligence is transforming the world.</div>
        <div class="sample-sentence" data-text="Welcome to Neura, your digital companion.">Welcome to Neura, your digital companion.</div>
        <div class="sample-sentence" data-text="1234567890 !@#$%^&*() Special characters and numbers.">1234567890 !@#$%^&*() Special characters and numbers.</div>
      </div>
    </div>
  </div>

  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
      }
    }
  </script>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
    import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
    import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
    import { ShaderPass } from 'three/addons/postprocessing/ShaderPass.js';

    console.log('Script starting');

    // UI Elements
    const stopButton = document.getElementById('stop-button');
    const currentTextElement = document.getElementById('current-text');
    const sampleSentences = document.querySelectorAll('.sample-sentence');

    // State
    let animationFrameId = null;
    let currentGradientPattern = 0;
    let lastPatternChangeTime = 0;
    let isAnimating = false;
    let currentText = "";
    let currentCharIndex = 0;
    let charAnimationStartTime = 0;
    let currentCharDuration = 0;
    let textQueue = [];
    let previousCharParams = null;
    let currentCharParams = null;
    let transitionProgress = 0;

    // Three.js variables
    let scene, camera, renderer, composer;
    let controls;
    let glassSphere, innerSphere;
    let shadowPlane;
    let clock = new THREE.Clock();
    let envMap, hdriTexture;

    // Character animation mappings with more varied heights
    const charMappings = {
      // Lowercase letters
      'a': { amplitude: 0.04, frequency: 2.0, speed: 0.8, heightMap: [0.7, 1.2, 0.5, 1.0, 0.8] },
      'b': { amplitude: 0.05, frequency: 2.2, speed: 0.7, heightMap: [1.0, 0.6, 1.3, 0.7, 0.9] },
      'c': { amplitude: 0.03, frequency: 2.5, speed: 0.9, heightMap: [0.5, 1.1, 0.8, 1.2, 0.6] },
      'd': { amplitude: 0.06, frequency: 2.3, speed: 0.8, heightMap: [1.2, 0.7, 1.0, 0.5, 1.3] },
      'e': { amplitude: 0.03, frequency: 3.0, speed: 1.0, heightMap: [0.8, 1.3, 0.6, 1.1, 0.7] },
      'f': { amplitude: 0.05, frequency: 2.7, speed: 0.9, heightMap: [1.1, 0.5, 1.2, 0.8, 1.0] },
      'g': { amplitude: 0.07, frequency: 2.0, speed: 0.7, heightMap: [0.9, 1.4, 0.6, 1.2, 0.7] },
      'h': { amplitude: 0.05, frequency: 2.5, speed: 0.8, heightMap: [1.3, 0.7, 1.1, 0.5, 1.0] },
      'i': { amplitude: 0.03, frequency: 3.2, speed: 1.1, heightMap: [0.6, 1.0, 0.8, 1.3, 0.5] },
      'j': { amplitude: 0.06, frequency: 2.3, speed: 0.9, heightMap: [1.2, 0.6, 1.4, 0.7, 1.1] },
      'k': { amplitude: 0.05, frequency: 2.6, speed: 0.8, heightMap: [0.8, 1.2, 0.5, 1.0, 0.7] },
      'l': { amplitude: 0.04, frequency: 2.8, speed: 0.9, heightMap: [1.0, 0.5, 1.3, 0.8, 1.1] },
      'm': { amplitude: 0.06, frequency: 2.2, speed: 0.7, heightMap: [0.7, 1.4, 0.6, 1.2, 0.9] },
      'n': { amplitude: 0.05, frequency: 2.5, speed: 0.8, heightMap: [1.1, 0.6, 1.0, 0.8, 1.3] },
      'o': { amplitude: 0.04, frequency: 2.7, speed: 0.9, heightMap: [0.8, 1.2, 0.7, 1.0, 0.6] },
      'p': { amplitude: 0.06, frequency: 2.3, speed: 0.8, heightMap: [1.3, 0.7, 1.1, 0.5, 1.2] },
      'q': { amplitude: 0.07, frequency: 2.1, speed: 0.7, heightMap: [0.9, 1.4, 0.6, 1.1, 0.8] },
      'r': { amplitude: 0.05, frequency: 2.6, speed: 0.9, heightMap: [1.0, 0.5, 1.2, 0.7, 1.3] },
      's': { amplitude: 0.04, frequency: 2.8, speed: 1.0, heightMap: [0.6, 1.1, 0.8, 1.3, 0.7] },
      't': { amplitude: 0.05, frequency: 2.5, speed: 0.9, heightMap: [1.2, 0.6, 1.0, 0.8, 1.1] },
      'u': { amplitude: 0.04, frequency: 2.7, speed: 0.8, heightMap: [0.7, 1.3, 0.5, 1.1, 0.9] },
      'v': { amplitude: 0.05, frequency: 2.4, speed: 0.9, heightMap: [1.1, 0.7, 1.3, 0.6, 1.0] },
      'w': { amplitude: 0.06, frequency: 2.2, speed: 0.7, heightMap: [0.8, 1.4, 0.6, 1.2, 0.7] },
      'x': { amplitude: 0.07, frequency: 2.0, speed: 0.8, heightMap: [1.3, 0.5, 1.1, 0.8, 1.2] },
      'y': { amplitude: 0.05, frequency: 2.5, speed: 0.9, heightMap: [0.7, 1.2, 0.6, 1.0, 0.8] },
      'z': { amplitude: 0.06, frequency: 2.3, speed: 0.8, heightMap: [1.0, 0.6, 1.3, 0.7, 1.1] },
      
      // Uppercase letters (significantly more pronounced)
      'A': { amplitude: 0.09, frequency: 1.8, speed: 0.7, heightMap: [1.5, 0.8, 1.3, 0.6, 1.2] },
      'B': { amplitude: 0.08, frequency: 2.0, speed: 0.6, heightMap: [0.9, 1.6, 0.7, 1.4, 0.8] },
      'C': { amplitude: 0.07, frequency: 2.3, speed: 0.8, heightMap: [1.4, 0.7, 1.5, 0.6, 1.3] },
      'D': { amplitude: 0.09, frequency: 2.1, speed: 0.7, heightMap: [0.8, 1.5, 0.6, 1.3, 0.9] },
      'E': { amplitude: 0.06, frequency: 2.8, speed: 0.9, heightMap: [1.3, 0.6, 1.4, 0.7, 1.2] },
      'F': { amplitude: 0.08, frequency: 2.5, speed: 0.8, heightMap: [0.7, 1.6, 0.8, 1.4, 0.6] },
      'G': { amplitude: 0.10, frequency: 1.8, speed: 0.6, heightMap: [1.5, 0.7, 1.3, 0.9, 1.6] },
      'H': { amplitude: 0.08, frequency: 2.3, speed: 0.7, heightMap: [0.8, 1.4, 0.6, 1.5, 0.7] },
      'I': { amplitude: 0.06, frequency: 3.0, speed: 1.0, heightMap: [1.3, 0.5, 1.2, 0.8, 1.4] },
      'J': { amplitude: 0.09, frequency: 2.1, speed: 0.8, heightMap: [0.7, 1.6, 0.9, 1.3, 0.6] },
      'K': { amplitude: 0.08, frequency: 2.4, speed: 0.7, heightMap: [1.4, 0.6, 1.5, 0.8, 1.2] },
      'L': { amplitude: 0.07, frequency: 2.6, speed: 0.8, heightMap: [0.9, 1.5, 0.7, 1.3, 0.8] },
      'M': { amplitude: 0.09, frequency: 2.0, speed: 0.6, heightMap: [1.6, 0.7, 1.4, 0.6, 1.5] },
      'N': { amplitude: 0.08, frequency: 2.3, speed: 0.7, heightMap: [0.8, 1.5, 0.6, 1.4, 0.9] },
      'O': { amplitude: 0.07, frequency: 2.5, speed: 0.8, heightMap: [1.3, 0.6, 1.5, 0.7, 1.2] },
      'P': { amplitude: 0.09, frequency: 2.1, speed: 0.7, heightMap: [0.7, 1.6, 0.8, 1.3, 0.6] },
      'Q': { amplitude: 0.10, frequency: 1.9, speed: 0.6, heightMap: [1.5, 0.8, 1.4, 0.7, 1.6] },
      'R': { amplitude: 0.08, frequency: 2.4, speed: 0.8, heightMap: [0.9, 1.4, 0.6, 1.5, 0.8] },
      'S': { amplitude: 0.07, frequency: 2.6, speed: 0.9, heightMap: [1.3, 0.5, 1.4, 0.7, 1.2] },
      'T': { amplitude: 0.08, frequency: 2.3, speed: 0.8, heightMap: [0.6, 1.5, 0.8, 1.3, 0.7] },
      'U': { amplitude: 0.07, frequency: 2.5, speed: 0.7, heightMap: [1.4, 0.6, 1.3, 0.8, 1.5] },
      'V': { amplitude: 0.08, frequency: 2.2, speed: 0.8, heightMap: [0.7, 1.6, 0.9, 1.4, 0.6] },
      'W': { amplitude: 0.09, frequency: 2.0, speed: 0.6, heightMap: [1.5, 0.7, 1.3, 0.8, 1.6] },
      'X': { amplitude: 0.10, frequency: 1.8, speed: 0.7, heightMap: [0.8, 1.7, 0.6, 1.5, 0.9] },
      'Y': { amplitude: 0.08, frequency: 2.3, speed: 0.8, heightMap: [1.4, 0.5, 1.6, 0.7, 1.3] },
      'Z': { amplitude: 0.09, frequency: 2.1, speed: 0.7, heightMap: [0.6, 1.5, 0.8, 1.4, 0.7] },
      
      // Numbers (more structured patterns with varied heights)
      '0': { amplitude: 0.06, frequency: 3.0, speed: 1.0, heightMap: [1.0, 0.8, 1.2, 0.7, 1.1] },
      '1': { amplitude: 0.05, frequency: 3.2, speed: 1.1, heightMap: [0.6, 1.3, 0.5, 1.1, 0.8] },
      '2': { amplitude: 0.06, frequency: 3.0, speed: 1.0, heightMap: [1.2, 0.6, 1.4, 0.7, 1.0] },
      '3': { amplitude: 0.07, frequency: 2.8, speed: 0.9, heightMap: [0.8, 1.5, 0.6, 1.2, 0.9] },
      '4': { amplitude: 0.06, frequency: 3.0, speed: 1.0, heightMap: [1.3, 0.7, 1.1, 0.5, 1.4] },
      '5': { amplitude: 0.07, frequency: 2.8, speed: 0.9, heightMap: [0.7, 1.4, 0.8, 1.2, 0.6] },
      '6': { amplitude: 0.06, frequency: 3.0, speed: 1.0, heightMap: [1.1, 0.5, 1.3, 0.7, 1.0] },
      '7': { amplitude: 0.05, frequency: 3.2, speed: 1.1, heightMap: [0.6, 1.5, 0.7, 1.3, 0.8] },
      '8': { amplitude: 0.06, frequency: 3.0, speed: 1.0, heightMap: [1.2, 0.6, 1.0, 0.8, 1.4] },
      '9': { amplitude: 0.07, frequency: 2.8, speed: 0.9, heightMap: [0.7, 1.3, 0.5, 1.1, 0.9] },
      
      // Special characters (more erratic patterns with extreme heights)
      '!': { amplitude: 0.10, frequency: 1.5, speed: 0.5, heightMap: [1.8, 0.3, 1.5, 0.4, 1.7] },
      '@': { amplitude: 0.09, frequency: 1.7, speed: 0.6, heightMap: [0.2, 1.7, 0.4, 1.6, 0.3] },
      '#': { amplitude: 0.08, frequency: 1.9, speed: 0.7, heightMap: [1.6, 0.2, 1.8, 0.3, 1.5] },
      '$': { amplitude: 0.09, frequency: 1.7, speed: 0.6, heightMap: [0.3, 1.8, 0.2, 1.6, 0.4] },
      '%': { amplitude: 0.10, frequency: 1.5, speed: 0.5, heightMap: [1.7, 0.3, 1.5, 0.2, 1.8] },
      '^': { amplitude: 0.09, frequency: 1.7, speed: 0.6, heightMap: [0.2, 1.6, 0.4, 1.7, 0.3] },
      '&': { amplitude: 0.08, frequency: 1.9, speed: 0.7, heightMap: [1.5, 0.3, 1.8, 0.2, 1.6] },
      '*': { amplitude: 0.10, frequency: 1.5, speed: 0.5, heightMap: [0.3, 1.7, 0.2, 1.8, 0.4] },
      '(': { amplitude: 0.07, frequency: 2.0, speed: 0.8, heightMap: [1.4, 0.4, 1.3, 0.5, 1.5] },
      ')': { amplitude: 0.07, frequency: 2.0, speed: 0.8, heightMap: [0.5, 1.5, 0.4, 1.3, 0.6] },
      '-': { amplitude: 0.05, frequency: 2.5, speed: 1.0, heightMap: [1.2, 0.5, 1.0, 0.6, 1.1] },
      '_': { amplitude: 0.06, frequency: 2.3, speed: 0.9, heightMap: [0.6, 1.3, 0.5, 1.2, 0.7] },
      '+': { amplitude: 0.07, frequency: 2.0, speed: 0.8, heightMap: [1.4, 0.5, 1.3, 0.6, 1.2] },
      '=': { amplitude: 0.06, frequency: 2.3, speed: 0.9, heightMap: [0.5, 1.2, 0.6, 1.3, 0.4] },
      '{': { amplitude: 0.08, frequency: 1.9, speed: 0.7, heightMap: [1.5, 0.3, 1.4, 0.4, 1.6] },
      '}': { amplitude: 0.08, frequency: 1.9, speed: 0.7, heightMap: [0.4, 1.6, 0.3, 1.5, 0.5] },
      '[': { amplitude: 0.07, frequency: 2.0, speed: 0.8, heightMap: [1.3, 0.4, 1.5, 0.3, 1.4] },
      ']': { amplitude: 0.07, frequency: 2.0, speed: 0.8, heightMap: [0.3, 1.4, 0.5, 1.3, 0.4] },
      '|': { amplitude: 0.05, frequency: 2.5, speed: 1.0, heightMap: [1.2, 0.3, 1.1, 0.4, 1.3] },
      '\\': { amplitude: 0.06, frequency: 2.3, speed: 0.9, heightMap: [0.4, 1.5, 0.3, 1.4, 0.5] },
      ':': { amplitude: 0.05, frequency: 2.5, speed: 1.0, heightMap: [1.1, 0.4, 1.2, 0.3, 1.0] },
      ';': { amplitude: 0.06, frequency: 2.3, speed: 0.9, heightMap: [0.3, 1.3, 0.4, 1.2, 0.5] },
      '"': { amplitude: 0.05, frequency: 2.5, speed: 1.0, heightMap: [1.2, 0.3, 1.0, 0.4, 1.1] },
      "'": { amplitude: 0.04, frequency: 2.7, speed: 1.1, heightMap: [0.4, 1.1, 0.3, 1.0, 0.5] },
      '<': { amplitude: 0.07, frequency: 2.0, speed: 0.8, heightMap: [1.4, 0.3, 1.3, 0.4, 1.5] },
      '>': { amplitude: 0.07, frequency: 2.0, speed: 0.8, heightMap: [0.4, 1.5, 0.3, 1.4, 0.5] },
      ',': { amplitude: 0.04, frequency: 2.7, speed: 1.1, heightMap: [1.0, 0.3, 0.9, 0.4, 1.1] },
      '.': { amplitude: 0.03, frequency: 3.0, speed: 1.2, heightMap: [0.3, 1.0, 0.4, 0.9, 0.5] },
      '/': { amplitude: 0.06, frequency: 2.3, speed: 0.9, heightMap: [1.3, 0.4, 1.2, 0.5, 1.4] },
      '?': { amplitude: 0.08, frequency: 1.9, speed: 0.7, heightMap: [0.3, 1.6, 0.4, 1.5, 0.5] },
      ' ': { amplitude: 0.01, frequency: 1.0, speed: 0.5, heightMap: [0.2, 0.3, 0.1, 0.2, 0.3] },
      
      // Default for any other character
      'default': { amplitude: 0.05, frequency: 2.5, speed: 0.9, heightMap: [1.0, 0.5, 1.2, 0.6, 0.8] }
    };

    // Predefined gradient patterns
    const gradientPatterns = [
      { // Swirl pattern
        speed: 0.5,
        direction: new THREE.Vector3(1, 0.5, 0.3),
        colorShift: 0.2
      },
      { // Vertical wave
        speed: 0.3,
        direction: new THREE.Vector3(0, 1, 0.2),
        colorShift: 0.4
      },
      { // Horizontal bands
        speed: 0.4,
        direction: new THREE.Vector3(0.8, 0.1, 0.5),
        colorShift: 0.3
      },
      { // Diagonal flow
        speed: 0.6,
        direction: new THREE.Vector3(0.7, 0.7, 0),
        colorShift: 0.5
      },
      { // Radial pulse
        speed: 0.35,
        direction: new THREE.Vector3(0.3, 0.3, 1),
        colorShift: 0.25
      }
    ];

    // Initialize Three.js scene
    function initThree() {
      console.log('Initializing Three.js');
      
      // Create scene
      scene = new THREE.Scene();
      
      // Create camera
      camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.z = 5;
      
      // Create renderer with physically correct lighting
      renderer = new THREE.WebGLRenderer({ 
        antialias: true, 
        alpha: true,
        physicallyCorrectLights: true
      });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setClearColor(0x111111);
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      renderer.toneMapping = THREE.ACESFilmicToneMapping;
      renderer.toneMappingExposure = 1.2;
      renderer.outputEncoding = THREE.sRGBEncoding;
      
      // Add renderer to DOM
      document.getElementById('canvas-container').appendChild(renderer.domElement);
      
      // Add orbit controls but disable rotation
      controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.05;
      controls.minDistance = 3;
      controls.maxDistance = 10;
      controls.autoRotate = false; // Disable auto-rotation
      controls.enableRotate = false; // Disable manual rotation
      
      // Create environment map for reflections
      createEnvironmentMap();
      
      // Add lights
      setupLighting();
      
      // Create glass sphere
      createGlassSphere();
      
      // Create inner sphere with gradient
      createInnerSphere();
      
      // Create shadow plane
      createShadowPlane();
      
      // Setup post-processing
      setupPostProcessing();
      
      // Handle window resize
      window.addEventListener('resize', onWindowResize);
      
      console.log('Three.js initialization complete');
    }

    // Create environment map for reflections
    function createEnvironmentMap() {
      // Create a subtle gradient environment for reflections
      const pmremGenerator = new THREE.PMREMGenerator(renderer);
      pmremGenerator.compileEquirectangularShader();
      
      // Create a simple gradient environment
      const canvas = document.createElement('canvas');
      canvas.width = 2048;
      canvas.height = 1024;
      const context = canvas.getContext('2d');
      
      // Create gradient
      const gradient = context.createLinearGradient(0, 0, 0, canvas.height);
      gradient.addColorStop(0, '#111122');
      gradient.addColorStop(1, '#222233');
      
      // Fill background
      context.fillStyle = gradient;
      context.fillRect(0, 0, canvas.width, canvas.height);
      
      // Add some subtle light spots for reflections
      context.fillStyle = 'rgba(255, 255, 255, 0.08)';
      context.beginPath();
      context.arc(canvas.width * 0.3, canvas.height * 0.2, 150, 0, Math.PI * 2);
      context.fill();
      
      context.fillStyle = 'rgba(255, 255, 255, 0.05)';
      context.beginPath();
      context.arc(canvas.width * 0.7, canvas.height * 0.3, 200, 0, Math.PI * 2);
      context.fill();
      
      context.fillStyle = 'rgba(200, 220, 255, 0.07)';
      context.beginPath();
      context.arc(canvas.width * 0.5, canvas.height * 0.8, 180, 0, Math.PI * 2);
      context.fill();
      
      // Convert to texture
      const texture = new THREE.CanvasTexture(canvas);
      texture.mapping = THREE.EquirectangularReflectionMapping;
      
      // Generate environment map
      envMap = pmremGenerator.fromEquirectangular(texture).texture;
      
      // Clean up
      texture.dispose();
      pmremGenerator.dispose();
      
      // Set scene environment
      scene.environment = envMap;
    }

    // Setup lighting
    function setupLighting() {
      // Ambient light for base illumination
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.2);
      scene.add(ambientLight);
      
      // Main directional light (from top-right)
      const mainLight = new THREE.DirectionalLight(0xffffff, 1.2);
      mainLight.position.set(5, 5, 5);
      mainLight.castShadow = true;
      mainLight.shadow.mapSize.width = 1024;
      mainLight.shadow.mapSize.height = 1024;
      mainLight.shadow.camera.near = 0.5;
      mainLight.shadow.camera.far = 20;
      mainLight.shadow.camera.left = -5;
      mainLight.shadow.camera.right = 5;
      mainLight.shadow.camera.top = 5;
      mainLight.shadow.camera.bottom = -5;
      mainLight.shadow.bias = -0.0001;
      scene.add(mainLight);
      
      // Fill light (from bottom-left)
      const fillLight = new THREE.DirectionalLight(0xffffff, 0.4);
      fillLight.position.set(-5, -2, -5);
      scene.add(fillLight);
      
      // Rim light for edge highlighting
      const rimLight = new THREE.DirectionalLight(0xffffff, 0.6);
      rimLight.position.set(0, 0, -10);
      scene.add(rimLight);
      
      // Spot light for dramatic highlight
      const spotLight = new THREE.SpotLight(0xffffff, 0.8);
      spotLight.position.set(3, 5, 2);
      spotLight.angle = Math.PI / 6;
      spotLight.penumbra = 0.2;
      spotLight.decay = 2;
      spotLight.distance = 50;
      spotLight.castShadow = true;
      spotLight.shadow.mapSize.width = 1024;
      spotLight.shadow.mapSize.height = 1024;
      scene.add(spotLight);
    }

    // Create glass sphere with wave distortion
    function createGlassSphere() {
      const geometry = new THREE.SphereGeometry(1, 128, 128);
      
      // Custom shader material for glass with wave distortion
      const material = new THREE.ShaderMaterial({
        uniforms: {
          time: { value: 0 },
          amplitude: { value: 0.0 },
          frequency: { value: 2.5 },
          speed: { value: 0.9 },
          heightMap: { value: [1.0, 1.0, 1.0, 1.0, 1.0] },
          transitionProgress: { value: 0.0 },
          prevAmplitude: { value: 0.0 },
          prevFrequency: { value: 2.5 },
          prevSpeed: { value: 0.9 },
          prevHeightMap: { value: [1.0, 1.0, 1.0, 1.0, 1.0] },
          envMap: { value: envMap },
          refractionRatio: { value: 0.985 },
          fresnelBias: { value: 0.1 },
          fresnelScale: { value: 2.0 },
          fresnelPower: { value: 2.0 }
        },
        vertexShader: `
          uniform float time;
          uniform float amplitude;
          uniform float frequency;
          uniform float speed;
          uniform float heightMap[5];
          uniform float transitionProgress;
          uniform float prevAmplitude;
          uniform float prevFrequency;
          uniform float prevSpeed;
          uniform float prevHeightMap[5];
          
          varying vec3 vReflect;
          varying vec3 vRefract[3];
          varying float vReflectionFactor;
          varying vec3 vPosition;
          varying vec3 vNormal;
          
          // Simplex noise functions
          vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
          vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
          vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }
          vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }
          
          float snoise(vec3 v) {
            const vec2 C = vec2(1.0/6.0, 1.0/3.0);
            const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);
            
            // First corner
            vec3 i  = floor(v + dot(v, C.yyy));
            vec3 x0 = v - i + dot(i, C.xxx);
            
            // Other corners
            vec3 g = step(x0.yzx, x0.xyz);
            vec3 l = 1.0 - g;
            vec3 i1 = min(g.xyz, l.zxy);
            vec3 i2 = max(g.xyz, l.zxy);
            
            vec3 x1 = x0 - i1 + C.xxx;
            vec3 x2 = x0 - i2 + C.yyy;
            vec3 x3 = x0 - D.yyy;
            
            // Permutations
            i = mod289(i);
            vec4 p = permute(permute(permute(
                     i.z + vec4(0.0, i1.z, i2.z, 1.0))
                   + i.y + vec4(0.0, i1.y, i2.y, 1.0))
                   + i.x + vec4(0.0, i1.x, i2.x, 1.0));
                   
            // Gradients
            float n_ = 0.142857142857;
            vec3 ns = n_ * D.wyz - D.xzx;
            
            vec4 j = p - 49.0 * floor(p * ns.z * ns.z);
            
            vec4 x_ = floor(j * ns.z);
            vec4 y_ = floor(j - 7.0 * x_);
            
            vec4 x = x_ *ns.x + ns.yyyy;
            vec4 y = y_ *ns.x + ns.yyyy;
            vec4 h = 1.0 - abs(x) - abs(y);
            
            vec4 b0 = vec4(x.xy, y.xy);
            vec4 b1 = vec4(x.zw, y.zw);
            
            vec4 s0 = floor(b0)*2.0 + 1.0;
            vec4 s1 = floor(b1)*2.0 + 1.0;
            vec4 sh = -step(h, vec4(0.0));
            
            vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;
            vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;
            
            vec3 p0 = vec3(a0.xy, h.x);
            vec3 p1 = vec3(a0.zw, h.y);
            vec3 p2 = vec3(a1.xy, h.z);
            vec3 p3 = vec3(a1.zw, h.w);
            
            // Normalise gradients
            vec4 norm = taylorInvSqrt(vec4(dot(p0, p0), dot(p1, p1), dot(p2, p2), dot(p3, p3)));
            p0 *= norm.x;
            p1 *= norm.y;
            p2 *= norm.z;
            p3 *= norm.w;
            
            // Mix final noise value
            vec4 m = max(0.6 - vec4(dot(x0, x0), dot(x1, x1), dot(x2, x2), dot(x3, x3)), 0.0);
            m = m * m;
            return 42.0 * dot(m*m, vec4(dot(p0, x0), dot(p1, x1), dot(p2, x2), dot(p3, x3)));
          }
          
          // Function to create varied wave heights based on character parameters and position
          float getWaveHeight(vec3 pos, float amp, float freq, float spd, float hMap[5]) {
            // Base noise with character-specific frequency
            float noise1 = snoise(vec3(pos.x * freq, pos.y * freq, pos.z * freq + time * spd));
            
            // Secondary noise with different frequency
            float noise2 = snoise(vec3(pos.x * freq * 2.0, pos.y * freq * 2.0, pos.z * freq * 2.0 + time * spd * 1.5));
            
            // Tertiary noise for fine details
            float noise3 = snoise(vec3(pos.x * freq * 4.0, pos.y * freq * 4.0, pos.z * freq * 4.0 + time * spd * 2.0));
            
            // Combine noises with different weights
            float combinedNoise = noise1 * 0.6 + noise2 * 0.3 + noise3 * 0.1;
            
            // Apply height variation based on position and height map
            float angle = atan(pos.z, pos.x);
            float normalizedAngle = (angle + 3.14159) / 6.28318; // Normalize to 0-1
            
            // Get height multiplier based on position
            int sector = int(normalizedAngle * 5.0);
            float heightMultiplier;
            
            // Apply height map based on position
            if (sector == 0) heightMultiplier = hMap[0];
            else if (sector == 1) heightMultiplier = hMap[1];
            else if (sector == 2) heightMultiplier = hMap[2];
            else if (sector == 3) heightMultiplier = hMap[3];
            else heightMultiplier = hMap[4];
            
            // Apply latitude variation (more at equator, less at poles)
            float latitudeVar = 1.0 - abs(pos.y);
            
            // Apply amplitude with height variation
            return combinedNoise * amp * heightMultiplier * latitudeVar;
          }
          
          void main() {
            // Calculate wave distortion with smooth transition between characters
            float currentDistortion = getWaveHeight(position, amplitude, frequency, speed, heightMap);
            float prevDistortion = getWaveHeight(position, prevAmplitude, prevFrequency, prevSpeed, prevHeightMap);
            
            // Smoothly interpolate between previous and current distortion
            float finalDistortion = mix(prevDistortion, currentDistortion, transitionProgress);
            
            // Apply distortion along normal
            vec3 newPosition = position + normal * finalDistortion;
            
            // Standard reflection/refraction calculations
            vec4 mvPosition = modelViewMatrix * vec4(newPosition, 1.0);
            vec4 worldPosition = modelMatrix * vec4(newPosition, 1.0);
            
            vPosition = worldPosition.xyz;
            vNormal = normalize(normalMatrix * normal);
            
            vec3 I = worldPosition.xyz - cameraPosition;
            
            // Reflection vector
            vReflect = reflect(I, normalize(normalMatrix * normal));
            
            // Refraction vectors
            float refractionRatio = 0.985;
            vRefract[0] = refract(normalize(I), normalize(worldPosition.xyz - cameraPosition), refractionRatio);
            vRefract[1] = refract(normalize(I), normalize(worldPosition.xyz - cameraPosition), refractionRatio * 0.99);
            vRefract[2] = refract(normalize(I), normalize(worldPosition.xyz - cameraPosition), refractionRatio * 0.98);
            
            // Fresnel term calculation
            float mFresnelBias = 0.1;
            float mFresnelScale = 2.0;
            float mFresnelPower = 2.0;
            
            float NdotI = dot(normalize(normalMatrix * normal), normalize(mvPosition.xyz));
            vReflectionFactor = mFresnelBias + mFresnelScale * pow(1.0 + NdotI, mFresnelPower);
            
            gl_Position = projectionMatrix * mvPosition;
          }
        `,
        fragmentShader: `
          uniform samplerCube envMap;
          uniform float time;
          
          varying vec3 vReflect;
          varying vec3 vRefract[3];
          varying float vReflectionFactor;
          varying vec3 vPosition;
          varying vec3 vNormal;
          
          void main() {
            // Reflection color
            vec4 reflectedColor = textureCube(envMap, vec3(-vReflect.x, vReflect.yz));
            
            // Refraction colors for RGB channels
            vec4 refractedColorR = textureCube(envMap, vec3(-vRefract[0].x, vRefract[0].yz));
            vec4 refractedColorG = textureCube(envMap, vec3(-vRefract[1].x, vRefract[1].yz));
            vec4 refractedColorB = textureCube(envMap, vec3(-vRefract[2].x, vRefract[2].yz));
            
            // Combine refraction colors
            vec4 refractedColor = vec4(refractedColorR.r, refractedColorG.g, refractedColorB.b, 1.0);
            
            // Mix reflection and refraction based on Fresnel factor
            vec4 finalColor = mix(refractedColor, reflectedColor, clamp(vReflectionFactor, 0.0, 1.0));
            
            // Add subtle blue tint to edges
            vec3 viewDirection = normalize(cameraPosition - vPosition);
            float fresnel = dot(viewDirection, vNormal);
            fresnel = pow(1.0 - fresnel, 3.0);
            
            vec3 blueTint = vec3(0.8, 0.9, 1.0) * fresnel * 0.15;
            
            // Final color with blue tint
            gl_FragColor = vec4(finalColor.rgb + blueTint, 0.95);
          }
        `,
        transparent: true
      });
      
      glassSphere = new THREE.Mesh(geometry, material);
      glassSphere.castShadow = true;
      glassSphere.receiveShadow = true;
      glassSphere.position.y = 0.5; // Floating effect
      scene.add(glassSphere);
    }

    // Create inner sphere with animated gradient
    function createInnerSphere() {
      const geometry = new THREE.SphereGeometry(0.92, 64, 64);
      
      // Custom shader material for animated gradient
      const material = new THREE.ShaderMaterial({
        uniforms: {
          time: { value: 0 },
          patternSpeed: { value: gradientPatterns[0].speed },
          patternDirection: { value: gradientPatterns[0].direction },
          colorShift: { value: gradientPatterns[0].colorShift },
          activated: { value: 0.0 }
        },
        vertexShader: `
          varying vec2 vUv;
          varying vec3 vPosition;
          
          void main() {
            vUv = uv;
            vPosition = position;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
          }
        `,
        fragmentShader: `
          uniform float time;
          uniform float activated;
          uniform float patternSpeed;
          uniform vec3 patternDirection;
          uniform float colorShift;
          
          varying vec2 vUv;
          varying vec3 vPosition;
          
          // Simplex noise function
          vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
          vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
          vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }
          vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }
          
          float snoise(vec3 v) {
            const vec2 C = vec2(1.0/6.0, 1.0/3.0);
            const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);
            
            // First corner
            vec3 i  = floor(v + dot(v, C.yyy));
            vec3 x0 = v - i + dot(i, C.xxx);
            
            // Other corners
            vec3 g = step(x0.yzx, x0.xyz);
            vec3 l = 1.0 - g;
            vec3 i1 = min(g.xyz, l.zxy);
            vec3 i2 = max(g.xyz, l.zxy);
            
            vec3 x1 = x0 - i1 + C.xxx;
            vec3 x2 = x0 - i2 + C.yyy;
            vec3 x3 = x0 - D.yyy;
            
            // Permutations
            i = mod289(i);
            vec4 p = permute(permute(permute(
                     i.z + vec4(0.0, i1.z, i2.z, 1.0))
                   + i.y + vec4(0.0, i1.y, i2.y, 1.0))
                   + i.x + vec4(0.0, i1.x, i2.x, 1.0));
                   
            // Gradients
            float n_ = 0.142857142857;
            vec3 ns = n_ * D.wyz - D.xzx;
            
            vec4 j = p - 49.0 * floor(p * ns.z * ns.z);
            
            vec4 x_ = floor(j * ns.z);
            vec4 y_ = floor(j - 7.0 * x_);
            
            vec4 x = x_ *ns.x + ns.yyyy;
            vec4 y = y_ *ns.x + ns.yyyy;
            vec4 h = 1.0 - abs(x) - abs(y);
            
            vec4 b0 = vec4(x.xy, y.xy);
            vec4 b1 = vec4(x.zw, y.zw);
            
            vec4 s0 = floor(b0)*2.0 + 1.0;
            vec4 s1 = floor(b1)*2.0 + 1.0;
            vec4 sh = -step(h, vec4(0.0));
            
            vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;
            vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;
            
            vec3 p0 = vec3(a0.xy, h.x);
            vec3 p1 = vec3(a0.zw, h.y);
            vec3 p2 = vec3(a1.xy, h.z);
            vec3 p3 = vec3(a1.zw, h.w);
            
            // Normalise gradients
            vec4 norm = taylorInvSqrt(vec4(dot(p0, p0), dot(p1, p1), dot(p2, p2), dot(p3, p3)));
            p0 *= norm.x;
            p1 *= norm.y;
            p2 *= norm.z;
            p3 *= norm.w;
            
            // Mix final noise value
            vec4 m = max(0.6 - vec4(dot(x0, x0), dot(x1, x1), dot(x2, x2), dot(x3, x3)), 0.0);
            m = m * m;
            return 42.0 * dot(m*m, vec4(dot(p0, x0), dot(p1, x1), dot(p2, x2), dot(p3, x3)));
          }
          
          void main() {
            // Create animated noise based on pattern direction and speed
            float noiseScale = 2.0;
            vec3 noisePos = vPosition * noiseScale + patternDirection * time * patternSpeed;
            float noise = snoise(noisePos) * 0.5 + 0.5;
            
            // Create color gradient based on noise and pattern
            vec3 color1 = vec3(0.95, 0.95, 0.95); // Almost white
            vec3 color2 = vec3(0.8, 0.85, 0.9);   // Light blue-gray
            vec3 color3 = vec3(0.7, 0.75, 0.85);  // Slightly darker blue-gray
            
            // Animated color mixing
            float t1 = sin(time * patternSpeed * 0.5) * 0.5 + 0.5;
            float t2 = cos(time * patternSpeed * 0.3) * 0.5 + 0.5;
            
            // Mix colors based on noise and time
            vec3 baseColor = mix(color1, color2, noise);
            baseColor = mix(baseColor, color3, noise * t1 + (1.0 - noise) * t2);
            
            // Add subtle color shift
            float hueShift = sin(time * patternSpeed * 0.2) * colorShift;
            baseColor.r += hueShift;
            baseColor.g += hueShift * 0.5;
            baseColor.b -= hueShift * 0.3;
            
            // Add activation glow
            baseColor = mix(baseColor, vec3(0.95, 0.95, 1.0), activated * 0.2);
            
            // Add transparency gradient from center to edge
            float distFromCenter = length(vPosition) / 0.92;
            float alpha = 0.4 - distFromCenter * 0.3;
            
            gl_FragColor = vec4(baseColor, alpha);
          }
        `,
        transparent: true,
        blending: THREE.AdditiveBlending,
        depthWrite: false
      });
      
      innerSphere = new THREE.Mesh(geometry, material);
      innerSphere.position.y = 0.5; // Match outer sphere position
      scene.add(innerSphere);
    }

    // Create shadow plane
    function createShadowPlane() {
      // Create a plane to receive the shadow
      const planeGeometry = new THREE.PlaneGeometry(10, 10);
      const planeMaterial = new THREE.ShadowMaterial({
        opacity: 0.2,
        transparent: true
      });
      
      shadowPlane = new THREE.Mesh(planeGeometry, planeMaterial);
      shadowPlane.rotation.x = -Math.PI / 2;
      shadowPlane.position.y = -0.5;
      shadowPlane.receiveShadow = true;
      scene.add(shadowPlane);
    }

    // Setup post-processing
    function setupPostProcessing() {
      composer = new EffectComposer(renderer);
      const renderPass = new RenderPass(scene, camera);
      composer.addPass(renderPass);
      
      // Very subtle bloom for highlights
      const bloomPass = new UnrealBloomPass(
        new THREE.Vector2(window.innerWidth, window.innerHeight),
        0.15,  // strength
        0.5,   // radius
        0.85   // threshold
      );
      composer.addPass(bloomPass);
    }

    // Handle window resize
    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      composer.setSize(window.innerWidth, window.innerHeight);
    }

    // Animation loop
    function animate() {
      animationFrameId = requestAnimationFrame(animate);
      
      const delta = clock.getDelta();
      const elapsedTime = clock.getElapsedTime();
      
      // Update controls
      controls.update();
      
      // Update glass sphere shader uniforms
      if (glassSphere && glassSphere.material.uniforms) {
        glassSphere.material.uniforms.time.value = elapsedTime;
        
        // Handle text animation with smooth transitions
        if (isAnimating && currentText && currentCharIndex < currentText.length) {
          const charTime = elapsedTime - charAnimationStartTime;
          
          // Update transition progress for smooth animation between characters
          transitionProgress = Math.min(charTime / 0.15, 1.0); // 150ms transition
          glassSphere.material.uniforms.transitionProgress.value = transitionProgress;
          
          // If it's time to move to the next character
          if (charTime > currentCharDuration) {
            currentCharIndex++;
            charAnimationStartTime = elapsedTime;
            
            // If we've reached the end of the text
            if (currentCharIndex >= currentText.length) {
              // Wait a moment before processing the next text in queue
              setTimeout(() => {
                if (textQueue.length > 0) {
                  const nextText = textQueue.shift();
                  animateText(nextText);
                } else {
                  isAnimating = false;
                  // Reset to default state
                  previousCharParams = currentCharParams;
                  currentCharParams = getCharacterParams(' ');
                  updateCharacterAnimation(previousCharParams, currentCharParams);
                  transitionProgress = 0;
                  glassSphere.material.uniforms.transitionProgress.value = 0;
                  currentTextElement.textContent = '';
                }
              }, 1000);
            } else {
              // Update animation for the current character with smooth transition
              const currentChar = currentText[currentCharIndex];
              
              // Store previous parameters for smooth transition
              previousCharParams = currentCharParams;
              currentCharParams = getCharacterParams(currentChar);
              
              // Reset transition progress for new character
              transitionProgress = 0;
              glassSphere.material.uniforms.transitionProgress.value = 0;
              
              // Update the animation parameters
              updateCharacterAnimation(previousCharParams, currentCharParams);
              
              // Update the displayed text
              currentTextElement.textContent = currentText.substring(0, currentCharIndex + 1);
              
              // Calculate duration for this character (slightly random but longer for better visibility)
              currentCharDuration = 0.25 + Math.random() * 0.1;
            }
          }
        }
        
        // Subtle floating animation
        glassSphere.position.y = 0.5 + Math.sin(elapsedTime * 0.5) * 0.05;
      }
      
      // Update inner sphere with gradient
      if (innerSphere && innerSphere.material.uniforms) {
        innerSphere.material.uniforms.time.value = elapsedTime;
        innerSphere.material.uniforms.activated.value = isAnimating ? 1.0 : 0.0;
        
        // Match position with outer sphere
        innerSphere.position.y = glassSphere.position.y;
        
        // Change gradient pattern periodically
        if (elapsedTime - lastPatternChangeTime > 8.0) {
          changeGradientPattern();
          lastPatternChangeTime = elapsedTime;
        }
      }
      
      // Update shadow position
      if (shadowPlane) {
        shadowPlane.position.y = -0.5;
      }
      
      // Render scene with post-processing
      composer.render();
    }

    // Change gradient pattern randomly
    function changeGradientPattern() {
      let newPattern;
      do {
        newPattern = Math.floor(Math.random() * gradientPatterns.length);
      } while (newPattern === currentGradientPattern);
      
      currentGradientPattern = newPattern;
      
      if (innerSphere && innerSphere.material.uniforms) {
        const pattern = gradientPatterns[currentGradientPattern];
        innerSphere.material.uniforms.patternSpeed.value = pattern.speed;
        innerSphere.material.uniforms.patternDirection.value = pattern.direction;
        innerSphere.material.uniforms.colorShift.value = pattern.colorShift;
      }
    }

    // Get character animation parameters
    function getCharacterParams(char) {
      // Get character mapping or use default
      return charMappings[char] || charMappings['default'];
    }

    // Update character animation parameters with smooth transition
    function updateCharacterAnimation(prevParams, currentParams) {
      if (!glassSphere || !glassSphere.material.uniforms) return;
      
      // Update current parameters
      glassSphere.material.uniforms.amplitude.value = currentParams.amplitude;
      glassSphere.material.uniforms.frequency.value = currentParams.frequency;
      glassSphere.material.uniforms.speed.value = currentParams.speed;
      glassSphere.material.uniforms.heightMap.value = currentParams.heightMap;
      
      // Update previous parameters for transition
      glassSphere.material.uniforms.prevAmplitude.value = prevParams.amplitude;
      glassSphere.material.uniforms.prevFrequency.value = prevParams.frequency;
      glassSphere.material.uniforms.prevSpeed.value = prevParams.speed;
      glassSphere.material.uniforms.prevHeightMap.value = prevParams.heightMap;
    }

    // Animate text
    function animateText(text) {
      if (!text) return;
      
      // Reset animation state
      isAnimating = true;
      currentText = text;
      currentCharIndex = 0;
      charAnimationStartTime = clock.getElapsedTime();
      currentCharDuration = 0.25; // Initial duration (longer for better visibility)
      
      // Start with the first character
      const firstChar = text[0];
      previousCharParams = getCharacterParams(' '); // Start from neutral state
      currentCharParams = getCharacterParams(firstChar);
      
      // Reset transition for first character
      transitionProgress = 0;
      if (glassSphere && glassSphere.material.uniforms) {
        glassSphere.material.uniforms.transitionProgress.value = 0;
      }
      
      // Update animation parameters
      updateCharacterAnimation(previousCharParams, currentCharParams);
      
      // Display the first character
      currentTextElement.textContent = firstChar;
    }

    // Handle stop button click
    function handleStopButton() {
      isAnimating = false;
      textQueue = [];
      currentText = "";
      currentTextElement.textContent = '';
      
      // Reset to default state
      previousCharParams = currentCharParams || getCharacterParams(' ');
      currentCharParams = getCharacterParams(' ');
      updateCharacterAnimation(previousCharParams, currentCharParams);
      transitionProgress = 0;
      if (glassSphere && glassSphere.material.uniforms) {
        glassSphere.material.uniforms.transitionProgress.value = 0;
      }
    }

    // Handle sample sentence click
    function handleSampleSentenceClick(event) {
      const text = event.target.dataset.text;
      if (!text) return;
      
      // Clear any active states
      sampleSentences.forEach(sentence => {
        sentence.classList.remove('active');
      });
      
      // Add active state to clicked sentence
      event.target.classList.add('active');
      
      // If already animating, add to queue
      if (isAnimating) {
        textQueue.push(text);
      } else {
        animateText(text);
      }
    }

    // Initialize everything
    function init() {
      console.log('Initializing application');
      
      // Initialize Three.js
      initThree();
      
      // Add event listeners
      stopButton.addEventListener('click', handleStopButton);
      
      // Add event listeners to sample sentences
      sampleSentences.forEach(sentence => {
        sentence.addEventListener('click', handleSampleSentenceClick);
      });
      
      // Start animation loop
      animate();
      
      console.log('Initialization complete');
    }

    // Start the application
    init();
  </script>
</body>
</html>
